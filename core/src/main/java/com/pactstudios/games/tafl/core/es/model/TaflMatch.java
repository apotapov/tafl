package com.pactstudios.games.tafl.core.es.model;

import java.util.Date;

import com.badlogic.gdx.utils.Array;
import com.j256.ormlite.dao.ForeignCollection;
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.field.ForeignCollectionField;
import com.j256.ormlite.table.DatabaseTable;
import com.pactstudios.games.tafl.core.consts.Constants;
import com.pactstudios.games.tafl.core.enums.AiType;
import com.pactstudios.games.tafl.core.enums.LifeCycle;
import com.pactstudios.games.tafl.core.enums.RulesEngineType;
import com.pactstudios.games.tafl.core.es.model.ai.AiFactory;
import com.pactstudios.games.tafl.core.es.model.ai.AiStrategy;
import com.pactstudios.games.tafl.core.es.model.ai.optimization.BitBoard;
import com.pactstudios.games.tafl.core.es.model.ai.optimization.GameBoard;
import com.pactstudios.games.tafl.core.es.model.log.MatchLogEntry;
import com.pactstudios.games.tafl.core.es.model.rules.RulesEngine;
import com.pactstudios.games.tafl.core.es.model.rules.RulesFactory;
import com.pactstudios.games.tafl.core.utils.TaflDatabaseService;
import com.roundtriangles.games.zaria.utils.ModifiableString;

@DatabaseTable(tableName = Constants.DbConstants.MATCH_TABLE)
public class TaflMatch {

    public static final String ID_COLUMN = "_id";
    public static final String NAME_COLUMN = "name";
    public static final String STATUS_COLUMN = "status";
    public static final String TURN_COLUMN = "turn";
    public static final String RULE_ENGINE_COLUMN = "rules";
    public static final String CREATED_COLUMN = "created";
    public static final String UPDATED_COLUMN = "updated";
    public static final String TIMER_COLUMN = "timer";
    public static final String VERSUS_COMPUTER_COLUMN = "versus_computer";
    public static final String COMPUTER_TEAM_COLUMN = "computer_team";
    public static final String AI_TYPE_COLUMN = "ai_type";
    public static final String BOARD_REPRESENTATION_COLUMN = "board_representation";

    // id is generated by the database and set on the object automagically
    @DatabaseField(generatedId = true)
    public int _id;

    @DatabaseField(columnName = NAME_COLUMN, canBeNull = false)
    public String name;

    @DatabaseField(columnName = STATUS_COLUMN, canBeNull = false)
    public LifeCycle status;

    @DatabaseField(columnName = TURN_COLUMN, canBeNull = false)
    public int turn = Constants.BoardConstants.NO_TEAM;

    @DatabaseField(columnName = RULE_ENGINE_COLUMN, canBeNull = false)
    public RulesEngineType rulesType;

    @DatabaseField(columnName = CREATED_COLUMN, canBeNull = false)
    public Date created;

    @DatabaseField(columnName = UPDATED_COLUMN, canBeNull = false)
    public Date updated;

    @DatabaseField(columnName = TIMER_COLUMN, canBeNull = false)
    public float timer;

    @DatabaseField(columnName = VERSUS_COMPUTER_COLUMN, canBeNull = false)
    public boolean versusComputer;

    @DatabaseField(columnName = COMPUTER_TEAM_COLUMN)
    public int computerTeam = Constants.BoardConstants.NO_TEAM;

    @DatabaseField(columnName = AI_TYPE_COLUMN, canBeNull = false)
    public AiType aiType;

    @DatabaseField(columnName = BOARD_REPRESENTATION_COLUMN, canBeNull = false)
    public String boardRepresentation;


    @ForeignCollectionField
    public ForeignCollection<MatchLogEntry> persistedLog;

    public RulesEngine rulesEngine;
    public TaflBoard board;
    public AiStrategy aiStrategy;

    private ModifiableString boardString;

    public boolean computerStarts;

    public Array<TaflMatchObserver> observers;

    public TaflMatch() {
        observers = new Array<TaflMatchObserver>();
    }

    public void initialize(TaflDatabaseService dbService, TaflMatchObserver...observers) {
        initializeComponents(dbService);
        initializeStrings();
        intializeTurn();

        registerObservers(dbService, observers);
        initializeMatch();
    }

    private void intializeTurn() {
        if (turn == Constants.BoardConstants.NO_TEAM) {
            turn = rulesEngine.getFirstTurn();
        }
        if (versusComputer && computerTeam == Constants.BoardConstants.NO_TEAM) {
            int firstTurn = rulesEngine.getFirstTurn();
            int secondTurn = (firstTurn + 1) % 2;
            computerTeam = computerStarts ? firstTurn : secondTurn;
        }
    }

    private void initializeStrings() {
        StringBuilder builder = new StringBuilder(board.boardSize);
        for (int i = 0; i < board.boardSize; i++) {
            builder.append('0');
        }

        boardString = new ModifiableString(builder.toString());
    }

    private void initializeComponents(TaflDatabaseService dbService) {
        rulesEngine = RulesFactory.getRules(rulesType);
        board = new TaflBoard((int)Math.sqrt(boardRepresentation.length()),
                GameBoard.NUMBER_OF_TEAMS,
                dbService.hash,
                rulesEngine);
        aiStrategy = AiFactory.getAiStrategy(aiType, this, dbService);
    }

    private void initializeMatch() {
        for (TaflMatchObserver observer : observers) {
            observer.initializeMatch(this);
        }

        addPieces();

        for (TaflMatchObserver observer : observers) {
            observer.changeTurn(this);
        }
    }

    private void registerObservers(TaflDatabaseService dbService,
            TaflMatchObserver... observers) {
        registerObserver(rulesEngine);
        for (TaflMatchObserver observer : observers) {
            registerObserver(observer);
        }
        registerObserver(dbService);
    }

    public void registerObserver(TaflMatchObserver observer) {
        observers.add(observer);
    }

    private void addPieces() {
        for (int i = 0; i < boardRepresentation.length(); i++) {
            char current = boardRepresentation.charAt(i);
            if (current == Constants.BoardConstants.WHITE_PIECE) {
                addPiece(Constants.BoardConstants.WHITE_TEAM, i);
            } else if (current == Constants.BoardConstants.BLACK_PIECE) {
                addPiece(Constants.BoardConstants.BLACK_TEAM, i);
            } else if (current == Constants.BoardConstants.KING_PIECE) {
                board.king = i;
                addPiece(Constants.BoardConstants.WHITE_TEAM, i);
            }
        }
    }

    public String getBoardRepresentation() {

        BitBoard bitBoard = board.bitBoards[Constants.BoardConstants.WHITE_TEAM];
        for (int i = bitBoard.nextSetBit(0); i >= 0; i = bitBoard.nextSetBit(i+1)) {
            boardString.setChar(i, Constants.BoardConstants.WHITE_PIECE);
        }

        bitBoard = board.bitBoards[Constants.BoardConstants.BLACK_TEAM];
        for (int i = bitBoard.nextSetBit(0); i >= 0; i = bitBoard.nextSetBit(i+1)) {
            boardString.setChar(i, Constants.BoardConstants.BLACK_PIECE);
        }

        if (board.king != Constants.BoardConstants.ILLEGAL_CELL) {
            boardString.setChar(board.king, Constants.BoardConstants.KING_PIECE);
        }

        return boardString.toString();
    }

    @Override
    public int hashCode() {
        return name == null ? 0 : name.hashCode();
    }

    @Override
    public boolean equals(Object other) {
        return other != null &&
                other instanceof TaflMatch &&
                name != null &&
                name.equals(((TaflMatch)other).name);
    }

    @Override
    public String toString() {
        return Integer.toString(_id);
    }

    public void applyMove(TaflMove move, boolean simulate) {
        board.applyMove(move, simulate);
        if (!simulate) {
            for (TaflMatchObserver observer : observers) {
                observer.applyMove(this, move);
            }
        }
    }

    public TaflMove undoMove() {
        TaflMove move = board.undoMove();
        if (move != null) {
            for (TaflMatchObserver observer : observers) {
                observer.undoMove(this, move);
            }
            changeTurn();
            return move;
        }
        return null;
    }

    public void addPiece(int team, int piece) {
        board.addPiece(team, piece);

        for (TaflMatchObserver observer : observers) {
            observer.addPiece(this, team, piece);
        }
    }

    public void removePieces(int team, BitBoard capturedPieces) {
        board.removePieces(team, capturedPieces);

        for (TaflMatchObserver observer : observers) {
            observer.removePieces(this, team, capturedPieces);
        }
    }

    public boolean acceptInput() {
        return !versusComputer || turn != computerTeam;
    }

    public BitBoard currentBitBoard() {
        return board.bitBoards[turn];
    }

    public void changeTurn() {
        turn = (turn + 1) % 2;

        for (TaflMatchObserver observer : observers) {
            observer.changeTurn(this);
        }
    }

    public void gameOver(LifeCycle status) {
        this.status = status;
        for (TaflMatchObserver observer : observers) {
            observer.gameOver(this, status);
        }
    }
}
