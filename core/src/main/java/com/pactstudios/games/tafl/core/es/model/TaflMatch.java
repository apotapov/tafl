package com.pactstudios.games.tafl.core.es.model;

import java.util.Date;

import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Pools;
import com.j256.ormlite.dao.ForeignCollection;
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.field.ForeignCollectionField;
import com.j256.ormlite.table.DatabaseTable;
import com.pactstudios.games.tafl.core.consts.Constants;
import com.pactstudios.games.tafl.core.es.model.ai.AiStrategy;
import com.pactstudios.games.tafl.core.es.model.ai.AiStrategy.AiType;
import com.pactstudios.games.tafl.core.es.model.board.GameBoard;
import com.pactstudios.games.tafl.core.es.model.board.Move;
import com.pactstudios.games.tafl.core.es.model.board.cells.ModelCell;
import com.pactstudios.games.tafl.core.es.model.log.MatchLogEntry;
import com.pactstudios.games.tafl.core.es.model.objects.GamePiece;
import com.pactstudios.games.tafl.core.es.model.objects.Team;
import com.pactstudios.games.tafl.core.es.model.rules.RulesEngine;
import com.pactstudios.games.tafl.core.es.model.rules.RulesEngine.RulesEngineType;
import com.pactstudios.games.tafl.core.es.systems.events.LifecycleEvent.Lifecycle;

@DatabaseTable(tableName = Constants.DbConstants.MATCH_TABLE)
public class TaflMatch {

    public static final String ID_COLUMN = "_id";
    public static final String NAME_COLUMN = "name";
    public static final String STATUS_COLUMN = "status";
    public static final String TURN_COLUMN = "turn";
    public static final String DIMENSION_COLUMN = "dim";
    public static final String RULE_ENGINE_COLUMN = "rules";
    public static final String CREATED_COLUMN = "created";
    public static final String UPDATED_COLUMN = "updated";
    public static final String TIMER_COLUMN = "timer";
    public static final String VERSUS_COMPUTER_COLUMN = "versus_computer";
    public static final String COMPUTER_TEAM_COLUMN = "computer_team";
    public static final String AI_TYPE_COLUMN = "ai_type";

    public static final String[] COLUMN_MAP = new String[] {
        NAME_COLUMN,
        STATUS_COLUMN,
        TURN_COLUMN,
        DIMENSION_COLUMN,
        RULE_ENGINE_COLUMN,
        CREATED_COLUMN,
        UPDATED_COLUMN,
        TIMER_COLUMN,
        VERSUS_COMPUTER_COLUMN,
        COMPUTER_TEAM_COLUMN,
        AI_TYPE_COLUMN,
    };

    // id is generated by the database and set on the object automagically
    @DatabaseField(generatedId = true)
    public int _id;

    @DatabaseField(columnName = NAME_COLUMN, canBeNull = false)
    public String name;

    @DatabaseField(columnName = STATUS_COLUMN, canBeNull = false)
    public Lifecycle status;

    @DatabaseField(columnName = TURN_COLUMN, canBeNull = false)
    public Team turn;

    @DatabaseField(columnName = DIMENSION_COLUMN, canBeNull = false)
    public int dimensions;

    @DatabaseField(columnName = RULE_ENGINE_COLUMN, canBeNull = false)
    public RulesEngineType rulesType;

    @DatabaseField(columnName = CREATED_COLUMN, canBeNull = false)
    public Date created;

    @DatabaseField(columnName = UPDATED_COLUMN, canBeNull = false)
    public Date updated;

    @DatabaseField(columnName = TIMER_COLUMN, canBeNull = false)
    public float timer;

    @DatabaseField(columnName = VERSUS_COMPUTER_COLUMN, canBeNull = false)
    public boolean versusComputer;

    @DatabaseField(columnName = COMPUTER_TEAM_COLUMN)
    public Team computerTeam;

    @DatabaseField(columnName = AI_TYPE_COLUMN, canBeNull = false)
    public AiType aiType;

    @ForeignCollectionField
    public ForeignCollection<GamePiece> persistedPiece;

    @ForeignCollectionField
    public ForeignCollection<MatchLogEntry> persistedLog;

    public Array<GamePiece> pieces;
    public RulesEngine rulesEngine;
    public GameBoard board;
    public AiStrategy aiStrategy;

    public Array<Move> undoStack;
    public Array<Move> redoStack;
    public Array<Move> simulatedMoves;

    public TaflMatch() {
        undoStack = new Array<Move>();
        redoStack = new Array<Move>();
        simulatedMoves = new Array<Move>();
    }

    @Override
    public int hashCode() {
        return name == null ? 0 : name.hashCode();
    }

    @Override
    public boolean equals(Object other) {
        return other != null && other instanceof TaflMatch && name != null && name.equals(((TaflMatch)other).name);
    }

    @Override
    public String toString() {
        return Integer.toString(_id);
    }

    public void simulateMove(Move move) {
        if (move != null) {
            move.captured.addAll(rulesEngine.getCapturedPieces(move.end));
            for (GamePiece piece : move.captured) {
                board.getCell(piece.x, piece.y).piece = null;
            }
            applyMove(move, false);
            simulatedMoves.add(move);
        }
    }

    public void rollBackSimulatedMove() {
        if (simulatedMoves.size > 0) {
            Move move = simulatedMoves.pop();
            undoMove(move, false);
            for (GamePiece piece : move.captured) {
                board.getCell(piece.x, piece.y).piece = piece;
            }
        }
    }

    public void applyMove(Move move, boolean record) {
        move.start.piece = null;
        move.end.piece = move.piece;
        move.piece.x = move.end.x;
        move.piece.y = move.end.y;
        if (record) {
            Pools.freeAll(redoStack);
            redoStack.clear();
            undoStack.add(move);
        }
    }

    public void undoMove(Move move, boolean record) {
        move.start.piece = move.piece;
        move.end.piece = null;
        move.piece.x = move.start.x;
        move.piece.y = move.start.y;
        if (record) {
            redoStack.add(move);
        }
    }

    public Move undoMove() {
        if (undoStack.size > 0) {
            Move move = undoStack.pop();
            undoMove(move, true);
            return move;
        }
        return null;
    }

    public Move redoMove() {
        if (redoStack.size > 0) {
            Move move = redoStack.pop();
            applyMove(move, false);
            undoStack.add(move);
            return move;
        }
        return null;
    }

    public float getBoardDimensionWithBorders() {
        return dimensions * Constants.BoardConstants.TILE_SIZE +
                Constants.BoardConstants.BOARD_FRAME_WIDTH * 2;
    }

    public ModelCell getCastleCell() {
        return board.getCell(dimensions / 2, dimensions / 2);
    }

    public boolean acceptInput() {
        return !versusComputer || turn != computerTeam;
    }
}
