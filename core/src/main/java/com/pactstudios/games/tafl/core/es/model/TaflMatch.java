package com.pactstudios.games.tafl.core.es.model;

import java.util.BitSet;
import java.util.Date;

import com.artemis.Entity;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;
import com.j256.ormlite.dao.ForeignCollection;
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.field.ForeignCollectionField;
import com.j256.ormlite.table.DatabaseTable;
import com.pactstudios.games.tafl.core.consts.Constants;
import com.pactstudios.games.tafl.core.enums.AiType;
import com.pactstudios.games.tafl.core.enums.GameBoardType;
import com.pactstudios.games.tafl.core.enums.LifeCycle;
import com.pactstudios.games.tafl.core.enums.PieceType;
import com.pactstudios.games.tafl.core.enums.RulesEngineType;
import com.pactstudios.games.tafl.core.enums.Team;
import com.pactstudios.games.tafl.core.es.model.ai.AiFactory;
import com.pactstudios.games.tafl.core.es.model.ai.AiStrategy;
import com.pactstudios.games.tafl.core.es.model.board.GameBitBoard;
import com.pactstudios.games.tafl.core.es.model.board.Move;
import com.pactstudios.games.tafl.core.es.model.log.MatchLogEntry;
import com.pactstudios.games.tafl.core.es.model.rules.RulesEngine;
import com.pactstudios.games.tafl.core.es.model.rules.RulesFactory;
import com.pactstudios.games.tafl.core.utils.TaflDatabaseService;

@DatabaseTable(tableName = Constants.DbConstants.MATCH_TABLE)
public class TaflMatch {

    private static final String[] HORIZONTAL_CELL_ID = new String[] {
        "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
        "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
        "U", "V", "W", "X", "Y", "Z" };

    private static final String[] VERTICAL_CELL_ID = new String[] {
        "1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
        "11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
        "21", "22", "23", "24", "25", "26" };

    public static final String ID_COLUMN = "_id";
    public static final String NAME_COLUMN = "name";
    public static final String STATUS_COLUMN = "status";
    public static final String TURN_COLUMN = "turn";
    public static final String BOARD_TYPE = "boardType";
    public static final String RULE_ENGINE_COLUMN = "rules";
    public static final String CREATED_COLUMN = "created";
    public static final String UPDATED_COLUMN = "updated";
    public static final String TIMER_COLUMN = "timer";
    public static final String VERSUS_COMPUTER_COLUMN = "versus_computer";
    public static final String COMPUTER_TEAM_COLUMN = "computer_team";
    public static final String AI_TYPE_COLUMN = "ai_type";
    public static final String WHITE_PIECES_COLUMN = "white_pieces";
    public static final String BLACK_PIECES_COLUMN = "black_pieces";
    public static final String KING_COLUMN = "king";



    // id is generated by the database and set on the object automagically
    @DatabaseField(generatedId = true)
    public int _id;

    @DatabaseField(columnName = NAME_COLUMN, canBeNull = false)
    public String name;

    @DatabaseField(columnName = STATUS_COLUMN, canBeNull = false)
    public LifeCycle status;

    @DatabaseField(columnName = TURN_COLUMN, canBeNull = false)
    public Team turn;

    @DatabaseField(columnName = BOARD_TYPE, canBeNull = false)
    public GameBoardType boardType;

    @DatabaseField(columnName = RULE_ENGINE_COLUMN, canBeNull = false)
    public RulesEngineType rulesType;

    @DatabaseField(columnName = CREATED_COLUMN, canBeNull = false)
    public Date created;

    @DatabaseField(columnName = UPDATED_COLUMN, canBeNull = false)
    public Date updated;

    @DatabaseField(columnName = TIMER_COLUMN, canBeNull = false)
    public float timer;

    @DatabaseField(columnName = VERSUS_COMPUTER_COLUMN, canBeNull = false)
    public boolean versusComputer;

    @DatabaseField(columnName = COMPUTER_TEAM_COLUMN)
    public Team computerTeam;

    @DatabaseField(columnName = AI_TYPE_COLUMN, canBeNull = false)
    public AiType aiType;

    @DatabaseField(columnName = WHITE_PIECES_COLUMN, canBeNull = false)
    public String whitePieces;

    @DatabaseField(columnName = BLACK_PIECES_COLUMN, canBeNull = false)
    public String blackPieces;

    @DatabaseField(columnName = KING_COLUMN, canBeNull = false)
    public int king;

    @ForeignCollectionField
    public ForeignCollection<MatchLogEntry> persistedLog;

    public int selectedPiece;

    public Entity[] pieceEntities;

    public RulesEngine rulesEngine;
    public GameBitBoard board;
    public AiStrategy aiStrategy;

    public Array<Move> undoStack;
    public Array<Move> simulatedMoves;

    private Vector2 position;

    public int[] corners;
    public int center;

    public boolean computerStarts;

    public TaflMatch() {
        undoStack = new Array<Move>();
        simulatedMoves = new Array<Move>();

        position = new Vector2();
    }

    public void initialize(TaflDatabaseService dbService) {
        board = new GameBitBoard(boardType.dimensions,
                GameBitBoard.NUMBER_OF_TEAMS,
                dbService.hashs.get(boardType.dimensions));

        board.stringToBitSet(whitePieces, Team.WHITE.bitBoardId());
        board.stringToBitSet(blackPieces, Team.BLACK.bitBoardId());

        corners = new int[4];
        corners[0] = 0;
        corners[1] = board.dimensions - 1;
        corners[2] = board.dimensions * board.dimensions - board.dimensions;
        corners[3] = board.dimensions * board.dimensions - 1;
        center = (board.dimensions/2) * board.dimensions + (board.dimensions / 2);

        rulesEngine = RulesFactory.getRules(rulesType, this);

        aiStrategy = AiFactory.getAiStrategy(aiType);

        if (turn == null) {
            turn = rulesEngine.getFirstTurn();
        }
        if (computerTeam == null) {
            computerTeam = computerStarts ? rulesEngine.getFirstTurn() :
                rulesEngine.getSecondTurn();
        }
        if (_id == 0) {
            dbService.createMatch(this);
        }

        rulesEngine.calculateLegalMoves();
    }

    @Override
    public int hashCode() {
        return name == null ? 0 : name.hashCode();
    }

    @Override
    public boolean equals(Object other) {
        return other != null &&
                other instanceof TaflMatch &&
                name != null &&
                name.equals(((TaflMatch)other).name);
    }

    @Override
    public String toString() {
        return Integer.toString(_id);
    }

    public void simulateMove(Move move) {
        if (move != null) {
            applyMove(move, true);
            move.capturedPieces.addAll(rulesEngine.getCapturedPieces(move.destination));
            for (int i = 0; i < move.capturedPieces.size; i++) {
                board.bitBoards[(move.pieceType + 1) % 2].clear(move.capturedPieces.items[i]);
            }
            simulatedMoves.add(move);
        }
    }

    public void rollBackSimulatedMove() {
        if (simulatedMoves.size > 0) {
            Move move = simulatedMoves.pop();
            undoMove(move, true);
            for (int i = 0; i < move.capturedPieces.size; i++) {
                board.bitBoards[(move.pieceType + 1) % 2].set(move.capturedPieces.items[i]);
            }

        }
    }

    public void applyMove(Move move, boolean simulate) {
        BitSet bitBoard = board.bitBoards[move.pieceType];
        bitBoard.clear(move.source);
        bitBoard.set(move.destination);

        if (move.source == king) {
            king = move.destination;
        }

        if (!simulate) {
            Entity e = pieceEntities[move.source];
            pieceEntities[move.source] = null;
            pieceEntities[move.destination] = e;
            undoStack.add(move);
            rulesEngine.recordBoardConfiguration(board.hashCode());
        }
    }

    public void undoMove(Move move, boolean simulate) {
        BitSet bitBoard = board.bitBoards[move.pieceType];
        bitBoard.clear(move.destination);
        bitBoard.set(move.source);

        if (move.destination == king) {
            king = move.source;
        }

        if (!simulate) {
            Entity e = pieceEntities[move.destination];
            pieceEntities[move.destination] = null;
            pieceEntities[move.source] = e;
            rulesEngine.undoBoardConfiguration();
        }
    }

    public Move undoMove() {
        if (undoStack.size > 0) {
            Move move = undoStack.pop();
            undoMove(move, false);
            return move;
        }
        return null;
    }

    public float getBoardDimensionWithBorders() {
        return board.dimensions * Constants.BoardRenderConstants.TILE_SIZE +
                Constants.BoardRenderConstants.BOARD_FRAME_WIDTH * 2;
    }

    public boolean acceptInput() {
        return !versusComputer || turn != computerTeam;
    }

    public boolean canWalk(int cellId) {
        return center != cellId &&
                !isCornerCell(cellId);
    }

    public boolean isCornerCell(int cellId) {
        return corners[0] == cellId ||
                corners[1] == cellId ||
                corners[2] == cellId ||
                corners[3] == cellId;
    }

    public boolean isEmpty(int cellId) {
        for (BitSet bitBoard : board.bitBoards) {
            if (bitBoard.get(cellId)) {
                return true;
            }
        }
        return false;
    }

    public Team getTeam(int cellId) {
        if (board.bitBoards[Team.WHITE.bitBoardId()].get(cellId)) {
            return Team.WHITE;
        } else if (board.bitBoards[Team.BLACK.bitBoardId()].get(cellId)) {
            return Team.BLACK;
        }
        return null;
    }

    public PieceType getPieceType(int cellId) {
        if (cellId == king) {
            return PieceType.KING;
        } else {
            Team team = getTeam(cellId);
            if (team != null) {
                return team == Team.WHITE ? PieceType.WHITE : PieceType.BLACK;
            }
        }
        return null;
    }

    public void removePiece(int captor, int capturedPiece) {
        board.bitBoards[(captor + 1) % 2].clear(capturedPiece);

        if (capturedPiece == king) {
            king = Constants.BoardConstants.KING_DEAD;
        }
        Entity e = pieceEntities[capturedPiece];
        if (e != null) {
            e.deleteFromWorld();
            pieceEntities[capturedPiece] = null;
        }
    }


    public Vector2 getCellPosition(int cellId) {
        position.x = cellId % board.dimensions * Constants.BoardRenderConstants.TILE_SIZE +
                Constants.BoardRenderConstants.BOARD_FRAME_WIDTH;
        position.y = cellId / board.dimensions * Constants.BoardRenderConstants.TILE_SIZE +
                Constants.BoardRenderConstants.BOARD_FRAME_WIDTH;
        return position;
    }

    public Vector2 getCellPositionCenter(int cellId) {
        return getCellPosition(cellId).add(
                Constants.BoardRenderConstants.HALF_TILE_SIZE,
                Constants.BoardRenderConstants.HALF_TILE_SIZE);
    }

    public int getCellId(Vector2 screenPosition) {
        int x = (int)((screenPosition.x -
                Constants.BoardRenderConstants.BOARD_FRAME_WIDTH) /
                Constants.BoardRenderConstants.TILE_SIZE);
        int y = (int)((screenPosition.y -
                Constants.BoardRenderConstants.BOARD_FRAME_WIDTH) /
                Constants.BoardRenderConstants.TILE_SIZE);
        return y * board.dimensions + x;
    }

    public String getHorizontalCellId(int index) {
        return HORIZONTAL_CELL_ID[index];
    }

    public String getVerticalCellId(int index) {
        return VERTICAL_CELL_ID[index];
    }

    public String getCellName(int x, int y) {
        return HORIZONTAL_CELL_ID[x] + VERTICAL_CELL_ID[y];
    }
}
