package com.pactstudios.games.tafl.core.es.model;

import java.util.BitSet;
import java.util.Date;

import com.badlogic.gdx.utils.Array;
import com.j256.ormlite.dao.ForeignCollection;
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.field.ForeignCollectionField;
import com.j256.ormlite.table.DatabaseTable;
import com.pactstudios.games.tafl.core.consts.Constants;
import com.pactstudios.games.tafl.core.enums.AiType;
import com.pactstudios.games.tafl.core.enums.GameBoardType;
import com.pactstudios.games.tafl.core.enums.LifeCycle;
import com.pactstudios.games.tafl.core.enums.RulesEngineType;
import com.pactstudios.games.tafl.core.es.model.ai.AiFactory;
import com.pactstudios.games.tafl.core.es.model.ai.AiStrategy;
import com.pactstudios.games.tafl.core.es.model.ai.optimization.GameBoard;
import com.pactstudios.games.tafl.core.es.model.log.MatchLogEntry;
import com.pactstudios.games.tafl.core.es.model.rules.RulesEngine;
import com.pactstudios.games.tafl.core.es.model.rules.RulesFactory;
import com.pactstudios.games.tafl.core.utils.TaflDatabaseService;
import com.roundtriangles.games.zaria.utils.ModifiableString;

@DatabaseTable(tableName = Constants.DbConstants.MATCH_TABLE)
public class TaflMatch {

    public static final String ID_COLUMN = "_id";
    public static final String NAME_COLUMN = "name";
    public static final String STATUS_COLUMN = "status";
    public static final String TURN_COLUMN = "turn";
    public static final String BOARD_TYPE = "boardType";
    public static final String RULE_ENGINE_COLUMN = "rules";
    public static final String CREATED_COLUMN = "created";
    public static final String UPDATED_COLUMN = "updated";
    public static final String TIMER_COLUMN = "timer";
    public static final String VERSUS_COMPUTER_COLUMN = "versus_computer";
    public static final String COMPUTER_TEAM_COLUMN = "computer_team";
    public static final String AI_TYPE_COLUMN = "ai_type";
    public static final String WHITE_PIECES_COLUMN = "white_pieces";
    public static final String BLACK_PIECES_COLUMN = "black_pieces";
    public static final String KING_COLUMN = "king";

    // id is generated by the database and set on the object automagically
    @DatabaseField(generatedId = true)
    public int _id;

    @DatabaseField(columnName = NAME_COLUMN, canBeNull = false)
    public String name;

    @DatabaseField(columnName = STATUS_COLUMN, canBeNull = false)
    public LifeCycle status;

    @DatabaseField(columnName = TURN_COLUMN, canBeNull = false)
    public int turn = Constants.BoardConstants.NO_TEAM;

    @DatabaseField(columnName = BOARD_TYPE, canBeNull = false)
    public GameBoardType boardType;

    @DatabaseField(columnName = RULE_ENGINE_COLUMN, canBeNull = false)
    public RulesEngineType rulesType;

    @DatabaseField(columnName = CREATED_COLUMN, canBeNull = false)
    public Date created;

    @DatabaseField(columnName = UPDATED_COLUMN, canBeNull = false)
    public Date updated;

    @DatabaseField(columnName = TIMER_COLUMN, canBeNull = false)
    public float timer;

    @DatabaseField(columnName = VERSUS_COMPUTER_COLUMN, canBeNull = false)
    public boolean versusComputer;

    @DatabaseField(columnName = COMPUTER_TEAM_COLUMN)
    public int computerTeam = Constants.BoardConstants.NO_TEAM;

    @DatabaseField(columnName = AI_TYPE_COLUMN, canBeNull = false)
    public AiType aiType;

    @DatabaseField(columnName = WHITE_PIECES_COLUMN, canBeNull = false)
    public String whitePieces;

    @DatabaseField(columnName = BLACK_PIECES_COLUMN, canBeNull = false)
    public String blackPieces;

    @DatabaseField(columnName = KING_COLUMN, canBeNull = false)
    private int king;

    @ForeignCollectionField
    public ForeignCollection<MatchLogEntry> persistedLog;

    public RulesEngine rulesEngine;
    public TaflBoard board;
    public AiStrategy aiStrategy;

    public Array<TaflMove> undoStack;
    public Array<TaflMove> simulatedMoves;

    private ModifiableString whiteModifiableString;
    private ModifiableString blackModifiableString;

    public boolean computerStarts;

    public Array<TaflMatchObserver> observers;

    public TaflMatch() {
        undoStack = new Array<TaflMove>();
        simulatedMoves = new Array<TaflMove>();
        observers = new Array<TaflMatchObserver>();
    }

    public void initialize(TaflDatabaseService dbService, TaflMatchObserver...observers) {
        initializeComponents(dbService);
        initializeStrings();
        intializeTurn();

        registerObservers(dbService, observers);
        initializeMatch();
    }

    private void intializeTurn() {
        if (turn == Constants.BoardConstants.NO_TEAM) {
            turn = rulesEngine.getFirstTurn();
        }
        if (versusComputer && computerTeam == Constants.BoardConstants.NO_TEAM) {
            int firstTurn = rulesEngine.getFirstTurn();
            int secondTurn = (firstTurn + 1) % 2;
            computerTeam = computerStarts ? firstTurn : secondTurn;
        }
    }

    private void initializeStrings() {
        StringBuilder builder = new StringBuilder(board.numberCells);
        for (int i = 0; i < board.numberCells; i++) {
            builder.append('0');
        }
        whiteModifiableString = new ModifiableString(builder.toString());
        blackModifiableString = new ModifiableString(builder.toString());
    }

    private void initializeComponents(TaflDatabaseService dbService) {
        board = new TaflBoard(boardType.dimensions,
                GameBoard.NUMBER_OF_TEAMS,
                dbService.hashs.get(boardType.dimensions),
                king);

        board.initialize();

        rulesEngine = RulesFactory.getRules(rulesType);
        aiStrategy = AiFactory.getAiStrategy(aiType);
    }

    private void initializeMatch() {
        for (TaflMatchObserver observer : observers) {
            observer.initializeMatch(this);
        }

        addPieces();

        for (TaflMatchObserver observer : observers) {
            observer.changeTurn(this);
        }
    }

    private void registerObservers(TaflDatabaseService dbService,
            TaflMatchObserver... observers) {
        for (TaflMatchObserver observer : observers) {
            registerObserver(observer);
        }
        registerObserver(rulesEngine);
        registerObserver(dbService);
    }

    public void registerObserver(TaflMatchObserver observer) {
        observers.add(observer);
    }

    private void addPieces() {
        for (int i = 0; i < whitePieces.length(); i++) {
            if (whitePieces.charAt(i) == '1') {
                addPiece(Constants.BoardConstants.WHITE_TEAM, i);
            }
        }
        for (int i = 0; i < blackPieces.length(); i++) {
            if (blackPieces.charAt(i) == '1') {
                addPiece(Constants.BoardConstants.BLACK_TEAM, i);
            }
        }
    }

    public String getWhiteBitSetString() {
        BitSet bitBoard = board.bitBoards[Constants.BoardConstants.WHITE_TEAM];
        for (int i = 0; i < board.numberCells; i++) {
            whiteModifiableString.setChar(i, bitBoard.get(i) ? '1' : '0');
        }
        return whiteModifiableString.toString();
    }

    public String getBlackBitSetString() {
        BitSet bitBoard = board.bitBoards[Constants.BoardConstants.BLACK_TEAM];
        for (int i = 0; i < board.numberCells; i++) {
            blackModifiableString.setChar(i, bitBoard.get(i) ? '1' : '0');
        }
        return blackModifiableString.toString();
    }

    @Override
    public int hashCode() {
        return name == null ? 0 : name.hashCode();
    }

    @Override
    public boolean equals(Object other) {
        return other != null &&
                other instanceof TaflMatch &&
                name != null &&
                name.equals(((TaflMatch)other).name);
    }

    @Override
    public String toString() {
        return Integer.toString(_id);
    }

    public void simulateMove(TaflMove move) {
        if (move != null) {
            applyMove(move, true);
            move.capturedPieces.clear();
            move.capturedPieces.or(rulesEngine.getCapturedPieces(move));
            board.bitBoards[(move.pieceType + 1) % 2].andNot(move.capturedPieces);
            simulatedMoves.add(move);
        }
    }

    public void rollBackSimulatedMove() {
        if (simulatedMoves.size > 0) {
            TaflMove move = simulatedMoves.pop();
            board.undoMove(move);
            board.bitBoards[(move.pieceType + 1) % 2].or(move.capturedPieces);
        }
    }

    public void applyMove(TaflMove move, boolean simulate) {
        board.applyMove(move);
        if (!simulate) {
            TaflMove clone = move.clone();
            undoStack.add(clone);
            for (TaflMatchObserver observer : observers) {
                observer.applyMove(this, clone);
            }
        }
    }

    public TaflMove undoMove() {
        if (undoStack.size > 0) {
            TaflMove move = undoStack.pop();
            board.undoMove(move);
            for (TaflMatchObserver observer : observers) {
                observer.undoMove(this, move);
            }
            changeTurn();
            return move;
        }
        return null;
    }

    public void addPiece(int team, int piece) {
        board.addPiece(team, piece);

        for (TaflMatchObserver observer : observers) {
            observer.addPiece(this, team, piece);
        }
    }

    public void removePieces(int captor, BitSet capturedPieces) {
        board.removePieces(captor, capturedPieces);

        for (TaflMatchObserver observer : observers) {
            observer.removePieces(this, captor, capturedPieces);
        }
    }

    public boolean acceptInput() {
        return !versusComputer || turn != computerTeam;
    }

    public BitSet currentBitBoard() {
        return board.bitBoards[turn];
    }

    public void updateKing(int king) {
        this.king = king;
    }

    public void changeTurn() {
        turn = (turn + 1) % 2;

        for (TaflMatchObserver observer : observers) {
            observer.changeTurn(this);
        }
    }

    public void gameOver(LifeCycle status) {
        this.status = status;
        for (TaflMatchObserver observer : observers) {
            observer.gameOver(this, status);
        }
    }
}
